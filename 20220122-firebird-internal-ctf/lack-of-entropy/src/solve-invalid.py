n = 12000757175764021771728105422729791606565179366618923088381518427772963308912563949439145385070769172972741398761479795911819036671300152410690967988704577578960611581687887245257451567890364405924219255756787341280550072273846466821947408031520082190686198511957083398506608222362286568755489463612423215773450674960198736152257
e = 65537
c = 7919665657024401743486247109689831499451743425111381588921175528994349469474004378058147448004067888729264935175219459544807223265650660870757505107216436997766453268592603771297281281281298342888643230431100692845508401973806493540818051245376797895620452653502018744173968082859530058752385383407628155344329148163919277658149

def recover_p(n, bits):
    MASK = (2<<len(bits)) - 1

    if len(bits) == 256:
        p = sum(r *  2**i for i, r in enumerate(bits))
        if n % p != 0: return []
        return [p]

    ps = []
    for b in [0, 1]:
        new_bits = bits + [b]
        p = sum(r *  2**i for i, r in enumerate(new_bits))
        q = sum(r * 10**i for i, r in enumerate(new_bits))

        if (p * q) & MASK == n & MASK:
            ps.extend(recover_p(n, new_bits))

    return ps

p, = recover_p(n, [])
q = n // p

phi_n = (p-1) * (q-1)
d = pow(e, -1, phi_n)

m = pow(c, d, n)
m = m.to_bytes((m.bit_length()+7)//8, 'big')
print(m)